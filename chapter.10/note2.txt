int (*pz)[2];  // pz points to an array of 2 ints
int *pax[2];   // pax is an array of two pointers-to-int

**********************************************************************
int *pt
int (*pa)[3];
int ar1[2][3];
int ar2[3][2];
int **p2;    // a pointer to a pointer


pt = &ar1[0][0];  // both pointer-to-int
pt = ar1[0];      // both pointer-to-int
pt = ar1;         // not valid
pa = ar1;         // both pointer-to-int[3]
pa = ar2;         // not valid
p2 = &pt;         // both pointer-to-int *
*p2 = ar2[0]      // both pointer-to-int
p2 = ar2          // not valid
***********************************************************************

Assigning a const pointer to a non-const pointer is not safe, because you could use the new pointer to alter const data.
But assigning a non-const pointer to a const pointer is okay, provided that you're dealing with just one level of 
indirection.

The compiler converts array notation to pointer notation. This means, for example, that ar[1] will become ar+1. For the
compiler to evaluate this, it needs to know the size object to which ar points.

int sum(int ar[][], int rows);   // faulty daclaration
int sum(int ar[3][4], int rows)  // valid declaration, 3 ignored.

In general, to declare a pointer corresponding to an N-dimensional array, you must supply values for all but the 
leftmost set of brackets.